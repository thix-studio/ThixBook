# Kotlin内联函数

Kotlin对于编译时常量会自动内联，但因为想要自动内联的同时保证正确性，所以限制比较多，必须是「编译时常量」，即 `const val` 修饰的基本类型或String类型对象。

而对于函数，为了兼顾「灵活性」和「正确性」，需要在代码中显式地通过一些关键字来修饰，告诉编译器应该如何内联，即 `inline` 、 `noinline` 和 `crossinline`。

示例代码：

```

    // 使用 inline 修饰函数，该函数会被内联，即函数体会被复制到调用处，
    // crossinline用于内部间接调用该函数参数时
    // noinline用于当函数参数作为对象被使用时（比如作为返回值被返回时），告诉编译器该函数不能被内联
    inline fun hello(crossinline postAction: () -> Unit, noinline returnAction: () -> String): String {
        println("hello ")
        runOnUIThread {
            // 间接调用该函数参数
            postAction()
        }
        // 函数参数作为对象使用
        return returnAction()
    }

    fun main() {
        hello ({
            println("world")
            // 该函数参数为 crossinline，因此该函数不能使用 return 语句
//            return
        }, {
            "return value"
        })
    }

```

## 一、inline

修饰函数，用于把函数内联。

- 优点：避免高阶函数中函数参数在运行时的对象创建，因为高阶函数可能在for循环或者其他高频调用场景中被调用，所以需要避免此类临时对象的创建；
- 缺点：如果函数体比较大，因为使用的地方可能很多，如果都内联，可能会导致最终字节码膨胀；
- 使用场景：高阶函数可能被高频调用时，使用 `inline` 内联，避免函数对象的创建，减少内存开销；

## 二、noinline

修饰内联函数的函数参数，关闭该函数参数的内联优化，属于局部关闭内联优化。

- 背景：函数内联后，return语句是作用于调用该函数的外层函数的（如上面的 `main` ），因此，为了保证正确性，不需要关心被调用函数是否被内联，kotlin规定lambda表达式内部不能使用 `return` 语句，除非这个lambda是内联函数的参数；
- 使用场景：当高阶函数的函数参数被作为对象使用时（比如作为返回值返回），为了保证程序正确性，需要避免该函数参数被内联；
- 优点：保证程序正确性；当需要使用该函数参数作为对象使用时，必须使用 `noinline` 关闭内联优化；这也是 `inline` 默认关闭、需要手动开启的其中一个原因；

## 三、crossinline

修饰内联函数的函数参数，用于「突破函数参数不能被间接使用」的限制，属于局部加强内联优化。

- 使用场景：当该函数参数需要在高阶函数中需要被间接使用时；
- 为什么需要：内联函数的函数参数不能在内联函数中被间接使用，因为该函数参数可能包含return语句，如果想要间接使用，必须加上 `crossinline` 关键字；
- 缺点：如果内联函数的函数参数使用 `crossinline` 修饰，表明该函数参数需要被间接使用，既然要间接使用，那该函数内部就不能使用 `return` 语句，否则 `return` 语句不知道应该结束内联后的外层函数，还是当前间接调用函数，因此这两种行为是互斥的，编译器会报错；
